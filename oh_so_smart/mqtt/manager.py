"""MQTT manager class that sends and receives MQTT messages from queues.

Copyright (C) 2025 Paulo Ferreira de Castro

Licensed under the Open Software License version 3.0, a copy of which can be
found in the LICENSE file.
"""

import asyncio
import logging
import time
from collections.abc import Iterable
from dataclasses import dataclass
from typing import Any

import paho.mqtt.client as mqtt
from paho.mqtt.enums import CallbackAPIVersion, MQTTProtocolVersion
from paho.mqtt.properties import Properties as MQTTProperties
from paho.mqtt.reasoncodes import ReasonCode
from paho.mqtt.subscribeoptions import SubscribeOptions

from ..config.schema import MQTTConfig
from .msg import Msg, MsgType
from .queue import MsgQueue


_LOGGER = logging.getLogger(__name__)


@dataclass
class PendingMsg:
    msg_info: mqtt.MQTTMessageInfo
    topic: str


class MQTTError(Exception):
    pass


class MQTTConnectTimeout(MQTTError):
    pass


class MQTTManager:
    """Send and receive MQTT messages with the event-based Paho MQTT library.

    The start() method creates asyncio tasks (long-lived loops) that:

    - Monitors events generated by the Paho MQTT client, such as message
      received events and error events, and appends received messages to the
      receive queue for consumption by other manager tasks (e.g. switch
      manager).
    - Monitors the send queue for messages produced by other manager tasks
      (e.g. sensor manager and switch manager), takes messages from that queue
      and awaits for the the Paho library to send them.
    """

    DISCONNECT_ABORT_SEC = 120.0
    LOOP_WAIT_SEC = 2.0

    def __init__(
        self,
        loop: asyncio.AbstractEventLoop,
        send_queue: MsgQueue[Msg],
        recv_queue: MsgQueue[mqtt.MQTTMessage],
        mqtt_config: MQTTConfig,
    ):
        self._error: MQTTError | None = None
        self._error_event = asyncio.Event()
        self._loop = loop
        self._send_queue = send_queue
        self._recv_queue = recv_queue

        self._client = client = mqtt.Client(
            callback_api_version=CallbackAPIVersion.VERSION2,
            client_id=mqtt_config.client_id,
            protocol=MQTTProtocolVersion.MQTTv5,
        )
        self._server = mqtt_config.server

        paho_logger = logging.getLogger("paho.mqtt")
        paho_logger.setLevel(logging.INFO)
        client.enable_logger(logger=paho_logger)
        client.username_pw_set(self._server.username, self._server.password)
        client.on_connect = self._on_connect
        client.on_connect_fail = self._on_connect_fail
        client.on_disconnect = self._on_disconnect
        client.on_message = self._on_message
        client.on_log = self._on_log
        client.on_subscribe = self._on_subscribe

        self._msg_count = 0
        self._got_disconnected = True
        self._on_connect_event = asyncio.Event()
        self._on_connect_messages: list[Msg] = []
        self._on_exit_messages: list[Msg] = []

    async def start(self):
        _LOGGER.info("%s: starting", type(self).__name__)

        async with asyncio.TaskGroup() as tg:
            tg.create_task(self._monitor_mqtt_errors())
            tg.create_task(self._manage_mqtt_client_task())

    async def _manage_mqtt_client_task(self):
        try:
            # Note: asyncio.CancelledError may be raised here
            await self._manage_mqtt_client()
        finally:
            _LOGGER.info("%s: shutting down", type(self).__name__)
            await self._shutdown()

    async def _manage_mqtt_client(self):
        self._client.connect_async(self._server.hostname, self._server.port, 60)
        res = self._client.loop_start()
        if res:
            raise MQTTError(f"mqtt.Client.loop_start() returned error code {res}")

        # Note that this loop may still get interrupted by CancelledError
        # if any other sibling task in a TaskGroup raises an exception, or
        # if any parent task gets cancelled.
        while True:
            try:
                if self._got_disconnected or not self._client.is_connected():
                    await self._wait_until_connected()
                    await self._run_on_connect_tasks()
                    self._got_disconnected = False

                # This call blocks for a short period of time if the queue is empty
                await self._process_send_queue()

            except MQTTError as e:
                # If not connected, give the Paho MQTT client a chance to reconnect
                if isinstance(e, MQTTConnectTimeout) or self._client.is_connected():
                    raise

    async def _monitor_mqtt_errors(self):
        await self._error_event.wait()
        raise self._error or MQTTError(
            f"{self._monitor_mqtt_errors.__name__}(): inconsistent state"
        )

    async def _shutdown(self):
        try:
            await self._publish_on_exit_messages()
        except Exception as e:
            _LOGGER.error(
                "Unable to publish on-exit messages: %s %s", type(e).__name__, e
            )

        rc = 0
        try:
            if self._client.is_connected():
                rc = self._client.disconnect()
        except Exception as e:
            _LOGGER.error(
                "Error attempting graceful MQTT disconnect: (rc=%d) %s %s",
                rc,
                type(e).__name__,
                e,
            )
        try:
            await self._stop_mqtt_client_thread(timeout_sec=3)
        except Exception as e:
            _LOGGER.error(
                "Unable to stop MQTT client thread: %s %s \n%s",
                type(e).__name__,
                e,
                "Quitting MQTT task anyway.",
            )

    async def _publish_on_exit_messages(self):
        if not self._on_exit_messages:
            return
        if self._client.is_connected():
            # Note: The timeout is per message.
            await self._publish_list(self._on_exit_messages, timeout_sec=2)
        else:
            _LOGGER.error(
                "Unable to publish on-exit messages: MQTT client not connected"
            )

    async def _stop_mqtt_client_thread(self, timeout_sec: float = 3):
        try:
            _LOGGER.debug("Waiting for MQTT client.loop_stop()...")
            await asyncio.wait_for(
                self._loop.run_in_executor(None, self._client.loop_stop),
                timeout_sec,
            )
            _LOGGER.debug("MQTT client.loop_stop() done")
        except TimeoutError:
            _LOGGER.debug("MQTT client.loop_stop() timed out")
            raise

    def _set_error(self, exc: MQTTError):
        self._error = exc
        self._error_event.set()

    async def _process_send_queue(self):
        try:
            msg = await self._send_queue.get(timeout_sec=self.LOOP_WAIT_SEC)
        except TimeoutError:
            return

        high_priority: list[Msg] = []
        low_priority: list[Msg] = []
        msgs = (msg, *self._send_queue.as_list())
        for msg in msgs:
            match msg.type:
                case MsgType.ON_CONNECT:
                    self._on_connect_messages.append(msg)
                    high_priority.append(msg)
                case MsgType.ON_EXIT:
                    self._on_exit_messages.append(msg)
                case MsgType.MQTT_WILL:
                    self._client.will_set(**msg.mqtt_args())
                case MsgType.SUBSCRIBE:
                    self._on_connect_messages.append(msg)
                    high_priority.append(msg)
                case _:
                    low_priority.append(msg)

        await self._publish_list(high_priority)
        await self._publish_list(low_priority)

    async def _wait_until_connected(self):
        """Wait until connected to the MQTT server and raise MQTTError if the wait exceeds DISCONNECT_ABORT_SEC."""

        # The on_disconnect event is generated BEFORE client.is_connected() returns
        # False, leading to temporary logic inconsistency (got disconnected but is
        # still reported connected). Work around this by waiting a bit.
        count = 0
        while self._got_disconnected and self._client.is_connected():
            if (count := count + 1) > 10:
                break
            await asyncio.sleep(0.1)

        disconnect_timestamp = time.monotonic()

        # Note that this loop may also get interrupted by CancelledError
        # if any other sibling task in a TaskGroup raises an exception.
        while not self._client.is_connected():
            elapsed = time.monotonic() - disconnect_timestamp
            remaining = self.DISCONNECT_ABORT_SEC - elapsed
            if remaining <= 0:
                host, port = self._server.hostname, self._server.port
                raise MQTTConnectTimeout(
                    f"Timeout waiting to connect to MQTT server '{host}:{port}'"
                )

            self._on_connect_event.clear()
            if not self._client.is_connected():
                try:
                    await asyncio.wait_for(
                        self._on_connect_event.wait(),
                        min(remaining, self.LOOP_WAIT_SEC),
                    )
                except TimeoutError:
                    pass

    async def _run_on_connect_tasks(self):
        await self._publish_list(self._on_connect_messages)

    def _subscribe(self, msg: Msg):
        res, _mid = self._client.subscribe(
            msg.topic,
            options=SubscribeOptions(qos=msg.qos, noLocal=True),
        )
        if res != mqtt.MQTT_ERR_SUCCESS:
            raise MQTTError(f"Failed to subscribe to topic '{msg.topic}' ({res=})")

    async def _publish(
        self,
        msg: Msg,
        *,
        wait: bool = True,
        timeout_sec: float = 3,
    ) -> mqtt.MQTTMessageInfo:
        msg_info = self._publish_nowait(msg)
        if wait:
            await self._wait_for_publish(msg_info, msg.topic, timeout_sec)
        return msg_info

    async def _publish_list(
        self,
        messages: Iterable[Msg],
        *,
        wait: bool = True,
        timeout_sec: float = 3,
    ):
        pending_publish: list[PendingMsg] = []

        for msg in messages:
            if msg.type is MsgType.SUBSCRIBE:
                self._subscribe(msg)
            else:
                msg_info = self._publish_nowait(msg)
                if wait:
                    pending_publish.append(PendingMsg(msg_info, msg.topic))

        for pmsg in pending_publish:
            await self._wait_for_publish(pmsg.msg_info, pmsg.topic, timeout_sec)

    def _publish_nowait(self, msg: Msg) -> mqtt.MQTTMessageInfo:
        payload = msg.payload
        if payload and len(payload) > 20:
            payload = payload[:17] + "..."
        _LOGGER.debug("Publishing to '%s': '%s'", msg.topic, payload)
        msg_info = self._client.publish(**msg.mqtt_args())
        return msg_info

    async def _wait_for_publish(
        self,
        msg_info: mqtt.MQTTMessageInfo,
        topic: str,
        timeout_sec: float = 3,
    ):
        try:
            await self._loop.run_in_executor(
                None,
                msg_info.wait_for_publish,
                timeout_sec,
            )
        except Exception as e:
            raise MQTTError(
                f"Error publishing to topic '{topic}' (rc={msg_info.rc})"
            ) from e

        if not msg_info.is_published():
            raise MQTTError(f"Timeout publishing to topic '{topic}'")

    def _on_connect(
        self,
        _client: mqtt.Client,
        _userdata: Any,
        _flags: dict,
        reason_code: ReasonCode,
        _properties: MQTTProperties | None,
    ):
        """The callback for when the client receives a CONNACK response from the server."""

        self._loop.call_soon_threadsafe(self._on_connect_event.set)

        if reason_code.value:
            _LOGGER.warning(
                "Failed to connect to MQTT server (rc=%d %s). Will retry.",
                reason_code.value,
                reason_code,
            )
            return

        _LOGGER.info(
            "Connected to MQTT server '%s:%d'",
            self._server.hostname,
            self._server.port,
        )

    def _on_connect_fail(self, _client: mqtt.Client, _userdata: Any):
        self._loop.call_soon_threadsafe(self._on_connect_event.set)
        _LOGGER.warning(
            "Failed to connect to MQTT server '%s:%d'. Will retry.",
            self._server.hostname,
            self._server.port,
        )

    def _on_disconnect(self, *_args, **_kwargs):
        self._got_disconnected = True

    def _on_message(self, _client: mqtt.Client, _userdata: Any, msg: mqtt.MQTTMessage):
        """The callback for when a PUBLISH message is received from the server."""
        try:
            self._recv_queue.put_nowait_threadsafe(msg)
        except asyncio.QueueFull as e:
            self._set_error(
                with_cause(MQTTError("Queue put operation failed: queue full"), e)
            )

    def _on_log(self, _client, _userdata, level, buf):
        if level != mqtt.MQTT_LOG_DEBUG:
            msg = f"{type(self).__name__} {self._on_log.__name__}() {level=} {buf=}"
            _LOGGER.debug(msg)
            if level == mqtt.MQTT_LOG_ERR:
                self._set_error(MQTTError(msg))

    def _on_subscribe(
        self, _client, _userdata, mid, reason_codes: Iterable[ReasonCode], _properties
    ):
        if __debug__:
            _LOGGER.debug(
                "on_subscribe callback: mid=%s reason_codes=%s",
                mid,
                [c.getName() for c in reason_codes],
            )
        bad_codes = [c for c in reason_codes if c.value > 127]
        if bad_codes:
            self._set_error(
                MQTTError(f"Subscribe error: {[c.getName() for c in bad_codes]}")
            )


def with_cause[E: Exception](exception: E, from_exception: Exception) -> E:
    exception.__cause__ = from_exception
    exception.__suppress_context__ = True
    return exception
